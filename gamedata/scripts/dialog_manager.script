-- ============================================================
--
-- Dialog Manager  (dialog_manager.script)
--	CoC 1.4.14 - DoctorX Questlines 1.9
--
--	Modified by: DoctorX
--	Last revised: October 30, 2016
--
-- ============================================================


--------------------------------------------------------------------------------
-- Dialog manager --------------------------------------------------------------
-- Made by Peacemaker ----------------------------------------------------------
-- 11.01.08 --------------------------------------------------------------------
--------------------------------------------------------------------------------
-- modified by Alundaio

RandomVal = 0
disabled_phrases = {} -- temporary table of phrases which have been disabled during a conversation
local quest_disabled_phrases = {} -- temporary table of phrases which have been disabled during a conversation
local id_counter = 6 -- start from 5 because of adding root phrases

phrase_table = {
					hello = {},
					job = {},
					anomalies = {},
					place = {},
					information = {},
					tips = {}
				}
priority_table = {
					hello = {},
					job = {},
					anomalies = {},
					place = {},
					information = {},
					tips = {}
				 }


----------------------- Alundaio easy scripted_dialog
local saved_dialog
--local cond_list = {}
function add_dialog(p_id,id,phrase_id,cond,act)
	if not ( saved_dialog ) then
		return
	end

	local phrase = saved_dialog:AddPhrase(phrase_id,tostring(id),tostring(p_id),-10000)
	if not ( phrase ) then
		return
	end

	--printf("phrase_id = %s",phrase_id)

	local phrase_script = phrase:GetPhraseScript()
	if ( cond ) then
		if ( type(cond) == "table" ) then
			for key, value in pairs(cond) do
				if (utils_data.findfunction(value,_G)) then
					phrase_script:AddPrecondition(value)
					--table.insert(cond_list,value)
				else
					printe("!ERROR dialog_manager | No such function exists '%s'",value)
				end
			end
		else
			if (utils_data.findfunction(cond,_G)) then
				phrase_script:AddPrecondition(cond)
				--table.insert(cond_list,value)
			else
				printe("!ERROR dialog_manager | No such function exists '%s'",cond)
			end
		end
	end

	if ( act ) then
		if ( type(act) == "table" ) then
			for key, value in pairs(act) do
				if (utils_data.findfunction(value,_G)) then
					phrase_script:AddAction(value)
				else
					printe("!ERROR dialog_manager | No such function exists '%s'",value)
				end
			end
		else
			if (utils_data.findfunction(act,_G)) then
				phrase_script:AddAction(act)
			else
				printe("!ERROR dialog_manager | No such function exists '%s'",act)
			end
		end
	end
	return phrase_script
end

function add_script_dialog(p_id,id,phrase_id,cond,act)
	local d = add_dialog(p_id,id,phrase_id,cond,act)
	if (d) then
		d:SetScriptText(phrase_id)
	end
end

-- Dialog structure for Meet Honcho and random storyline quest:
function drx_sl_init_honcho_meet_dialog( dialog )

	saved_dialog = dialog
	local base_id = 0

	-- Actor greets honcho:
	add_dialog( "", (base_id + 0), "st_drx_sl_meet_honcho" )  -- Actor

		-- Honcho explains current storyline task:
		add_script_dialog( (base_id + 0), (base_id + 1), "dialogs.drx_sl_text_honcho_has_storyline_task_to_give" )  -- NPC

			-- Actor accepts non-fetch storyline task:
			add_dialog( (base_id + 1), (base_id + 2), "st_drx_sl_accept_task", {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"}, "dialogs.drx_sl_give_sl_task" )  -- Actor

				-- Honcho affirms acceptance:
				add_dialog( (base_id + 2), (base_id + 3), "st_drx_sl_task_accepted" )  -- NPC

					-- Actor leaves honcho:
					add_dialog( (base_id + 3), (base_id + 4), "st_drx_sl_actor_exit", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor

			-- Actor accepts fetch storyline task:
			add_dialog( (base_id + 1), (base_id + 5), "st_drx_sl_accept_task", {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"} )  -- Actor

				-- Honcho explains fetch task
				add_script_dialog( (base_id + 5), (base_id + 6), "dialogs.drx_sl_text_fetch_task", nil, "dialogs.drx_sl_give_sl_task" )  -- NPC

					-- Actor leaves honcho:
					add_dialog( (base_id + 6), (base_id + 7), "st_drx_sl_actor_exit", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor

end

-- Dialog structure for changing factions:
function drx_sl_init_change_faction_dialog( dialog )

	saved_dialog = dialog
	local base_id = 0

	-- Actor requests to change factions:
	add_dialog( "", (base_id + 0), "st_drx_sl_change_factions_request" )  -- Actor

		-- NPC explains change factions task:
		add_script_dialog( (base_id + 0), (base_id + 1), "dialogs.drx_sl_text_npc_has_change_factions_task_to_give" )  -- NPC

			-- Actor accepts non-fetch change factions task:
			add_dialog( (base_id + 1), (base_id + 2), "st_drx_sl_accept_change_factions_task", {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"}, "dialogs.drx_sl_give_cf_task" )  -- Actor

				-- NPC affirms acceptance:
				add_dialog( (base_id + 2), (base_id + 3), "st_drx_sl_change_factions_task_accepted" )  -- NPC

					-- Actor leaves NPC:
					add_dialog( (base_id + 3), (base_id + 4), "st_drx_sl_change_factions_actor_exit", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor

			-- Actor accepts fetch change factions task:
			add_dialog( (base_id + 1), (base_id + 5), "st_drx_sl_accept_change_factions_task", {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"} )  -- Actor

				-- NPC explains fetch task
				add_script_dialog( (base_id + 5), (base_id + 6), "dialogs.drx_sl_text_fetch_task", nil, "dialogs.drx_sl_give_cf_task" )  -- NPC

					-- Actor leaves honcho:
					add_dialog( (base_id + 6), (base_id + 7), "st_drx_sl_change_factions_actor_exit", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor

			-- Actor refuses task and leaves NPC:
			add_dialog( (base_id + 1), (base_id + 8), "dm_universal_actor_exit", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor

end

-- Dialog structure for requesting mechanic task:
function drx_sl_init_mechanic_task_dialog( dialog )

	saved_dialog = dialog

	-- Actor requests task:
	add_dialog( "", 0, "st_ordered_task_query" )  -- Actor

		-- Honcho offers task:
		add_script_dialog( 0, 1, "dialogs.drx_sl_text_mechanic_has_ordered_task_to_give" )  -- Honcho

			-- Actor accepts non-fetch task:
			add_dialog( 1, 2, "st_ordered_task_accept", {"dialogs.not_task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"}, "dialogs.drx_sl_give_mechanic_task" )  -- Actor

				-- Honcho affirms acceptance:
				add_dialog( 2,3, ("st_accepted_task_" .. math.random( 1,3 )) )  -- Honcho

					-- Actor thanks honcho:
					add_dialog( 3,4, "dm_universal_actor_exit_thanks", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor

			-- Actor accepts fetch task:
			add_dialog( 1,5, "st_ordered_task_accept", {"dialogs.task_is_fetch_task", "dialogs.npc_has_ordered_task_to_give"} )  -- Actor

				-- Honcho explains fetch task:
				add_script_dialog( 5,6, "dialogs.drx_sl_text_fetch_task", nil, "dialogs.drx_sl_give_mechanic_task" )  -- Honcho

					-- Actor thanks honcho:
					add_dialog( 6,7, "dm_universal_actor_exit_thanks", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor
			
			add_dialog( 1, 14, "dm_universal_actor_exit", nil, "dialogs.npc_clear_skipped_tasks" )  -- Actor

end

-- Dialog structure for storyline task completed dialog:
function drx_sl_task_completed_dialog( dialog )

	saved_dialog = dialog

	-- Actor returns to honcho and states job is done:
	add_dialog( "", 0, "st_ordered_task_query_finished" )  -- Actor

		-- Honcho replies and sends to next honcho:
		add_script_dialog( 0, 1, "dialogs.drx_sl_text_task_finish", {"dialogs.drx_sl_actor_has_finished_task","dialogs.drx_sl_is_not_endgame"}, "dialogs.drx_sl_set_finished_task_complete" )  -- NPC

		-- Honcho replies and sends on End Game task:
		add_script_dialog( 0, 2, "dialogs.drx_sl_text_end_game", {"dialogs.drx_sl_actor_has_finished_task","dialogs.drx_sl_is_endgame"}, "dialogs.drx_sl_set_finished_task_complete_endgame" )  -- NPC

			-- Actor thanks honcho and leaves:
			add_dialog( 1, 3, "dm_universal_actor_exit_thanks" )  -- Actor

end

-- Dialog structure for storyline task completed dialog:
function drx_sl_cf_task_completed_dialog( dialog )

	saved_dialog = dialog

	-- Actor returns to npc and states job is done:
	add_dialog( "", 0, "st_ordered_task_query_finished" )  -- Actor

		-- NPC replies:
		add_script_dialog( 0, 1, "dialogs.drx_sl_text_cf_task_finish", {"dialogs.drx_sl_actor_has_finished_cf_task"}, "dialogs.drx_sl_set_finished_cf_task_complete" )  -- NPC

			-- Actor thanks npc and leaves:
			add_dialog( 1, 3, "dm_universal_actor_exit_thanks" )  -- Actor

end


-----------------------------------------------------
-- Dynamic Ashot and Yar Dialog
-----------------------------------------------------
function dm_ashot_and_yar(a,b)
	local npc = dialogs.who_is_npc(a,b)

end

-----------------------------------------------------
-- Dynamic task Dialog
-----------------------------------------------------

-- Dialog structure for requesting dynamic task from honcho:
function dm_init_dynamic_task_dialog(dialog)
	saved_dialog = dialog

	-- loop is necessary to allow skipping of unwanted tasks
	local base_id = 0
	
	-- ASK FOR AVAILABLE TASKS
	add_dialog("",base_id,"st_ordered_task_query","dialogs.check_task_stack","dialogs.generate_available_tasks")																							-- ACTOR
	
		add_dialog(base_id,base_id+900,"st_ordered_task_already","dialogs.has_tasks_by_npc","dialogs.confirm_task_stack")                                  								-- NPC
			add_dialog(base_id+900,base_id+901,"st_ordered_task_already_reply")
	for i=1,10 do
		add_script_dialog(base_id,base_id+1,"dialogs.text_npc_has_task","dialogs.not_has_tasks_by_npc")														-- NPC     <---|
			add_dialog(base_id+1,base_id+2,"st_ordered_task_accept","dialogs.npc_has_task","dialogs.npc_give_task")											-- ACTOR       |
				add_dialog(base_id+2,base_id+3,"st_accepted_task_"..math.random(1,3))																		-- NPC         |
					add_dialog(base_id+3,base_id+4,"dm_universal_actor_exit_thanks")																		-- ACTOR       |
																																							--             |
			add_dialog(base_id+1,base_id+10,"st_ordered_task_next","dialogs.npc_has_task","dialogs.npc_skip_task")											-- ACTOR   --->|
			add_dialog(base_id+1,base_id+8,"dm_universal_actor_exit")																					-- ACTOR
		base_id = base_id + 10
	end
end

function dm_init_sim_dynamic_task_dialog(dialog)
	saved_dialog = dialog

	-- loop is necessary to allow skipping of unwanted tasks
	local base_id = 0

	-- ASK FOR AVAILABLE TASKS
	add_dialog("",base_id,"st_ordered_task_query",nil,"dialogs.sim_generate_available_tasks")																						-- ACTOR
	
		--add_dialog(base_id,base_id+900,"st_ordered_task_already","dialogs.has_tasks_by_npc","dialogs.confirm_task_stack")
			--add_dialog(base_id+900,base_id+901,"st_ordered_task_already_reply")
	for i=1,10 do
		add_script_dialog(base_id,base_id+1,"dialogs.text_npc_has_task")																											-- NPC     <---|
			add_dialog(base_id+1,base_id+2,"st_ordered_task_accept","dialogs.npc_has_task","dialogs.npc_give_task")																	-- ACTOR       |
				add_dialog(base_id+2,base_id+3,"st_accepted_task_"..math.random(1,3))																								-- NPC         |
					add_dialog(base_id+3,base_id+4,"dm_universal_actor_exit_thanks")																								-- ACTOR       |
					                                                                                                                                                                --             |
			add_dialog(base_id+1,base_id+10,"st_ordered_task_next","dialogs.npc_has_task","dialogs.npc_skip_task")																	-- ACTOR   --->|
			add_dialog(base_id+1,base_id+8,"dm_universal_actor_exit") 																												-- ACTOR
		base_id = base_id + 10
	end
end

-- Dialog structure for ending a task:
function dm_init_dynamic_task_completed_dialog(dialog)

	saved_dialog = dialog



	add_dialog( "", 0, "st_ordered_task_query_finished" )  -- Actor

		add_script_dialog( 0, 1, "dialogs.text_task_finish", "dialogs.actor_has_finished_ordered_task", "dialogs.npc_set_finished_task_complete" )  -- NPC

			add_dialog( 1, 2, "dm_universal_actor_exit_thanks" )  -- Actor

end

-- Dialog structure for ending a simulation task:
function dm_init_sim_dynamic_task_completed_dialog( dialog )

	saved_dialog = dialog



	add_dialog( "", 0, "st_ordered_task_query_finished" )  -- Actor

		add_script_dialog( 0, 1, "dialogs.text_sim_task_finish", "dialogs.actor_sim_has_finished_ordered_task", "dialogs.npc_sim_set_finished_task_complete" )  -- NPC

			add_dialog( 1, 2, "dm_universal_actor_exit_thanks" )  -- Actor

end

function dm_init_dynamic_task_cancel_dialog(dialog)
	saved_dialog = dialog
	local base_id = 0
	
	-- CANCEL TASKS
	add_dialog("",base_id,"st_ordered_task_query_cancel","dialogs.actor_has_ongoing_task")																							-- ACTOR 

	for i=1,10 do
		add_script_dialog(base_id,base_id+1,"dialogs.text_npc_has_cancel_task")																										-- NPC     <---|
			add_script_dialog(base_id+1,base_id+2,"dialogs.text_actor_cancel_task","dialogs.npc_has_cancel_task", "dialogs.npc_cancel_task")											-- ACTOR       |
				add_script_dialog(base_id+2,base_id+3,"dialogs.text_task_cancel")																									-- NPC         |
					add_dialog(base_id+3,base_id+4,"dm_universal_actor_exit_sorry")																									-- ACTOR       |
					                                                                                                                                                                --             |
			add_dialog(base_id+1,base_id+10,"st_ordered_task_query_cancel_next_job","dialogs.npc_has_cancel_task","dialogs.npc_skip_cancel_task")									-- ACTOR   --->|
			add_dialog(base_id+1,base_id+8,"dm_universal_actor_exit") 																												-- ACTOR
		base_id = base_id + 10
	end	
end

function dm_init_sim_dynamic_task_cancel_dialog(dialog)
	saved_dialog = dialog
	local base_id = 0
	
	-- CANCEL TASKS
	add_dialog("",base_id,"st_ordered_task_query_cancel","dialogs.sim_actor_has_ongoing_task")																						-- ACTOR 

	for i=1,10 do
		add_script_dialog(base_id,base_id+1,"dialogs.text_npc_has_cancel_task")																										-- NPC     <---|
			add_script_dialog(base_id+1,base_id+2,"dialogs.text_actor_cancel_task","dialogs.npc_has_cancel_task", "dialogs.npc_cancel_task")											-- ACTOR       |
				add_script_dialog(base_id+2,base_id+3,"dialogs.text_task_cancel")																									-- NPC         |
					add_dialog(base_id+3,base_id+4,"dm_universal_actor_exit_sorry")																									-- ACTOR       |
					                                                                                                                                                                --             |
			add_dialog(base_id+1,base_id+10,"st_ordered_task_query_cancel_next_job","dialogs.npc_has_cancel_task","dialogs.npc_skip_cancel_task")									-- ACTOR   --->|
			add_dialog(base_id+1,base_id+8,"dm_universal_actor_exit") 																												-- ACTOR
		base_id = base_id + 10
	end	
end

-----------------------------------------------------
-- Dynamic Broker Dialog
-----------------------------------------------------
function dm_init_dynamic_broker_dialog(dialog)
	saved_dialog = dialog

	add_dialog("",0,"st_broker_query") 																		-- Actor
		add_dialog(0,1,"st_broker_npc_start_"..math.random(1,3)) 											-- NPC
			add_script_dialog(1,2,"dialogs.text_actor_has_valuable_item","dialogs.condition_actor_has_valuable_item") -- Actor
				add_dialog(2,3,"st_broker_npc_answer_pda_query") 											-- NPC
					add_dialog(3,4,"st_broker_give_pda") 													-- Actor
						add_script_dialog(4,5,"dialogs.text_trade_npc_pda") 								-- NPC
							--add_dialog(5,0,"st_broker_query_more")											-- Actor
							add_dialog(5,1111,"dm_universal_actor_exit_thanks")								-- Actor
			add_dialog(1,1111,"dm_universal_actor_exit") 													-- Actor
end

-----------------------------------------------------
-- Dynamic Yar and Ashot Dialog
-----------------------------------------------------
function dm_init_dynamic_ashot_and_yar_dialog(dialog)
	saved_dialog = dialog

	add_dialog("",0,"jup_b19_freedom_yar_task_1_dm_query")

	local script = add_dialog(0,1,"should not see this")
	script:SetScriptText("dialogs_jupiter.dm_ashot_and_yar_generate_dialog")
end

-----------------------------------------------------
-- Dynamic Repair Dialog
-----------------------------------------------------
function dm_init_dynamic_repair_dialog(dialog)
	saved_dialog = dialog

	add_dialog("",0,"st_mechanic_query_items")

	local script = add_dialog(0,1,"st_mechanic_repair_not_done","inventory_upgrades.dont_has_repaired_items")
	script:SetScriptText("inventory_upgrades.dm_repair_not_done")
	add_dialog(0,2,"st_mechanic_repair_done","inventory_upgrades.has_repaired_items","inventory_upgrades.give_repaired_items")
end


-----------------------------------------------------
-- Dynamic Surrender Dialog
-----------------------------------------------------
function dm_init_surrender_dialog(dialog)
	saved_dialog = dialog

	add_dialog("",0,"st_surrender_victim")

	add_dialog(0,1,"st_surrender_query_victim_4","dialogs.victim_is_bounty")
		add_script_dialog(1,9,"dialogs.surrender_victim_answers_bounty",nil,"dialogs.set_victim_surrendered")
			add_dialog(9,20,"st_surrender_actor_2",nil,"dialogs.break_dialog")
			
	add_dialog(0,2,"st_surrender_query_victim_1")
		add_script_dialog(2,10,"dialogs.surrender_victim_answers_1",nil,"dialogs.set_victim_surrendered")
			add_dialog(10,20,"st_surrender_actor_2",nil,"dialogs.break_dialog")

	add_dialog(0,4,"st_surrender_query_victim_3")
		add_script_dialog(4,12,"dialogs.surrender_victim_answers_2",nil,"dialogs.set_victim_surrendered")
			add_dialog(12,20,"st_surrender_actor_1",nil,"dialogs.break_dialog")
end

-----------------------------------------------------
-- Bandit squad leader in Agroprom Underground
-----------------------------------------------------
-- Dialog: starting dialog
function dm_agr_u_bandit_boss_start(dialog)
	saved_dialog = dialog

	add_dialog("",0,"st_agr_u_bandit_boss_dialog_start_0") -- NPC
		add_dialog(0,1,"st_agr_u_bandit_boss_dialog_start_1a") -- Actor
			add_dialog(1,4,"st_agr_u_bandit_boss_dialog_start_1a_1",nil,"dialogs_agr_u.give_info_agr_u_bandit_boss_start") -- NPC
		add_dialog(0,2,"st_agr_u_bandit_boss_dialog_start_1b") -- Actor
			add_dialog(2,5,"st_agr_u_bandit_boss_dialog_start_1b_1",nil,"dialogs_agr_u.give_info_agr_u_bandit_boss_start") -- NPC
		add_dialog(0,3,"st_agr_u_bandit_boss_dialog_start_1c") -- Actor
			add_dialog(3,6,"st_agr_u_bandit_boss_dialog_start_1c_1",nil,"dialogs_agr_u.give_info_agr_u_bandit_boss_start") -- NPC
end

-- Dialog: asking the bandit about the situation
function dm_agr_u_bandit_boss_ask(dialog)
	saved_dialog = dialog
	
	add_dialog("",0,"st_agr_u_bandit_boss_dialog_ask_0") -- Actor
		add_dialog(0,1,"st_agr_u_bandit_boss_dialog_ask_1",nil,"dialogs_agr_u.give_info_agr_u_bandit_boss_ask")	-- NPC
			add_dialog(1,2,"st_agr_u_bandit_boss_dialog_ask_2","dialogs_agr_u.actor_dont_has_agr_u_docs") -- Actor
				dm_agr_u_bandit_boss_reask(dialog, 2, 4)
			add_dialog(1,3,"st_agr_u_bandit_boss_dialog_ask_3") -- Actor
			dm_agr_u_bandit_boss_give_docs(dialog, 1, 30)
end

-- Dialog: accepting to help the bandit
function dm_agr_u_bandit_boss_reask(dialog, base_pid, next_pid)
	local b_id, n_id = 0, 1
	if next_pid and base_pid then
		n_id = next_pid 
		b_id = base_pid
	else
		saved_dialog = dialog
		add_dialog( "", b_id, "st_agr_u_bandit_boss_dialog_reask") -- Actor
	end
	
		add_dialog( b_id, n_id, "st_agr_u_bandit_boss_dialog_ask_5") -- NPC
			add_dialog( n_id, n_id+1, "st_agr_u_bandit_boss_dialog_ask_6") -- Actor
				add_dialog( n_id+1, n_id+2, "st_agr_u_bandit_boss_dialog_ask_7") -- NPC
					add_dialog( n_id+2, n_id+3, "st_agr_u_bandit_boss_dialog_ask_72") -- Actor
						add_dialog( n_id+3, n_id+4, "st_agr_u_bandit_boss_dialog_ask_73") -- NPC
							add_dialog( n_id+4, n_id+5, "st_agr_u_bandit_boss_dialog_ask_71", nil, {"dialogs_agr_u.give_agr_u_bandit_boss_task_1","dialogs_agr_u.set_speaker_as_companion","dialogs_agr_u.send_news_agr_u_bandit_boss_on_going"}) -- Actor
			add_dialog( n_id, n_id+6, "st_agr_u_bandit_boss_dialog_ask_8") -- Actor
				add_dialog( n_id+6, n_id+7, "st_agr_u_bandit_boss_dialog_ask_81", nil, "dialogs_agr_u.give_agr_u_bandit_boss_task_1") -- NPC
end

-- Dialog: giving the bandit the docs
function dm_agr_u_bandit_boss_give_docs(dialog, init_pid, base_pid)
	local i_id, b_id = "", 0
	if init_pid and base_pid then
		i_id = init_pid 
		b_id = base_pid
		add_dialog( i_id, b_id, "st_agr_u_bandit_boss_dialog_ask_4","dialogs_agr_u.actor_has_agr_u_docs","dialogs_agr_u.item_showcase_agr_u_docs") -- Actor
	else
		saved_dialog = dialog
		add_dialog( i_id, b_id, "st_agr_u_bandit_boss_dialog_give_docs_0", nil, "dialogs_agr_u.item_showcase_agr_u_docs") -- Actor
	end
	
	add_dialog(b_id,b_id+1,"st_agr_u_bandit_boss_dialog_ask_9") -- NPC
	
	-- Giving documents
	local function loop_here(n_id)
		add_dialog(n_id,n_id+1,"st_agr_u_bandit_boss_dialog_ask_10", nil, {"dialogs_agr_u.take_agr_u_docs","dialogs_agr_u.give_info_agr_u_bandit_boss_got_docs"}) -- Actor
			add_dialog( n_id+1, n_id+2, "st_agr_u_bandit_boss_dialog_give_docs_1", nil, "dialogs_agr_u.increase_goodwill_bandit_50")	-- NPC
				add_dialog( n_id+2, n_id+3, "st_agr_u_bandit_boss_dialog_give_docs_2") -- Actor
					add_dialog( n_id+3, n_id+4, "st_agr_u_bandit_boss_dialog_give_docs_3", nil, {"dialogs_agr_u.dimiss_agr_u_bandit_boss","dialogs_agr_u.give_af_blood_af_iam","dialogs_agr_u.give_info_agr_u_bandit_boss_task_completed_alt"})	-- NPC
						add_dialog( n_id+4, n_id+5, "st_agr_u_bandit_boss_dialog_give_docs_4", nil, {"dialogs.break_dialog","dialogs_agr_u.remove_agr_u_bandit_boss"}) -- Actor	
				add_dialog( n_id+2, n_id+6, "st_agr_u_bandit_boss_dialog_give_docs_5", nil, {"dialogs_agr_u.set_speaker_as_companion","dialogs_agr_u.give_agr_u_bandit_boss_task_1"}) -- Actor
	end
		loop_here(b_id+1)
	
	-- Bad turn
		add_dialog(b_id+1,b_id+10,"st_agr_u_bandit_boss_dialog_ask_11") -- Actor
			add_dialog(b_id+10,b_id+11,"st_agr_u_bandit_boss_dialog_ask_12") -- NPC
				add_dialog(b_id+11,b_id+12,"st_agr_u_bandit_boss_dialog_ask_13",nil,{"dialogs_agr_u.give_info_agr_u_bandit_boss_refused","dialogs_agr_u.dimiss_agr_u_bandit_boss","dialogs_agr_u.shoot_the_bitch"}) -- Actor
				add_dialog(b_id+11,b_id+13,"st_agr_u_bandit_boss_dialog_ask_14") -- Actor
					add_dialog(b_id+13,b_id+14,"st_agr_u_bandit_boss_dialog_ask_15") -- NPC
						loop_here(b_id+14)
end				

-- Dialog: returning to dark valley with the bandit
function dm_agr_u_bandit_boss_arrived(dialog)
	saved_dialog = dialog
	
	add_dialog("",0,"st_agr_u_bandit_boss_dialog_arrived_0") -- Actor
		add_dialog(0,1,"st_agr_u_bandit_boss_dialog_arrived_1",nil,{"dialogs_agr_u.dimiss_agr_u_bandit_boss","dialogs_agr_u.give_af_blood_af_iam","dialogs_agr_u.give_money_reward","dialogs_agr_u.give_info_agr_u_bandit_boss_task_completed"})	-- NPC
			add_dialog(1,2,"st_agr_u_bandit_boss_dialog_arrived_2") -- Actor
				add_dialog(2,3,"st_agr_u_bandit_boss_dialog_arrived_3")	-- NPC
					add_dialog(3,4,"st_agr_u_bandit_boss_dialog_arrived_4",nil,{"dialogs_agr_u.increase_goodwill_bandit_50","dialogs_agr_u.set_friendship_agr_u_bandit_boss","dialogs_agr_u.remove_agr_u_bandit_squad"}) -- Actor
end

-- End Alundaio
-----------------------------------------------------------------------------

-- Generate id for phrase
function get_id()
	id_counter = id_counter + 1
	return id_counter
end

-- Parse ini file and store all phrases and their parameters into phrase table
function fill_phrase_table()
	local cfg = ini_file_ex("misc\\dialog_manager.ltx")
	local function itr(section)
		local val = cfg:r_value(section,"category") or "default"
		local category = (val == "hello" or val == "anomalies" or val == "place" or val == "job" or val == "information" or val == "tips") and val or "default"
		if (category ~= "default") then 
			local temp_table = {}
			temp_table.info = {}
			temp_table.id = tostring(get_id())
			temp_table.name = section
			
			local temp = cfg:r_value(section,"npc_community")
			temp_table.npc_community = temp and parse_names(temp) or "not_set"
			
			temp = cfg:r_value(section,"actor_community")
			temp_table.actor_community = temp and parse_names(temp) or "not_set"
			
			temp = cfg:r_value(section,"level")
			temp_table.level = temp and parse_names(temp) or "not_set"
			
			temp_table.once = tostring(cfg:r_value(section,"once",1)) or "always"
			temp_table.wounded = tostring(cfg:r_value(section,"wounded",1)) or "false"

			temp = cfg:r_value(section,"info")
			if (temp and temp ~= "") then
				xr_logic.parse_infop1(temp_table.info, temp)
			end
			
			-- Tronex
			temp = cfg:r_value(section,"condition")
			temp_table.condition = temp and cfg:r_string_ex(section,"condition") or ""
			
			temp = cfg:r_value(section,"effect")
			temp_table.effect = temp and cfg:r_string_to_condlist(section,"effect") or ""
			
			temp_table.important = tostring(cfg:r_value(section,"important",1)) or "false"
			-- Tronex
			
			temp_table.smart = cfg:r_value(section,"smart") or ""

			phrase_table[category][temp_table.id] = temp_table
		end
	end 
	
	cfg.ini:section_for_each(itr)
end

-- Initialize npc start dialog
function init_start_dialogs(dialog, str)
	saved_dialog = dialog
	--cond_list = empty_table(cond_list)

	add_dialog("",0,"")
	add_dialog(0,1,"",nil,"dialog_manager.fill_priority_"..str.."_table")

	local ph
	local p,d
	local script
	for k,v in pairs(phrase_table[str]) do
		if (v.wounded == "true") then
			script = add_dialog(1,v.id,v.name,{"dialogs.is_wounded","dialog_manager.precondition_"..str.."_dialogs"},"dialog_manager.action_"..str.."_dialogs")
			if (script) then
				ph = true
				add_dialog(v.id,get_id(),"dm_wounded_medkit",{"dialogs.actor_have_medkit"},{"dialogs.transfer_medkit","dialogs.break_dialog"})
				add_dialog(v.id,get_id(),"dm_wounded_sorry",nil,"dialogs.break_dialog")
			end
		else
			add_dialog(1,v.id,v.name,{"dialogs.is_not_wounded","dialog_manager.precondition_"..str.."_dialogs"},"dialog_manager.action_"..str.."_dialogs")
			ph = true
		end
	end

	if not(ph) then
		add_dialog(1,2,"dm_"..str.."_general")
	end
end

-- Initialize new actor dialog
function init_new_dialog(dialog)
	local actor_table = { "job", "anomalies", "information", "tips" }

	saved_dialog = dialog
	add_dialog("",0,"dm_universal_actor_start")
	add_dialog(0,1,"dm_universal_npc_start_"..math.random(1,4))

	local ph,id,str

	for i = 1,4 do
		local id = get_id()
		str = actor_table[i]

		add_dialog(1,id,"dm_"..str.."_general_"..math.random(1,3),nil,"dialog_manager.fill_priority_"..str.."_table")
			local id2 = get_id()
			add_dialog(id,id2,"dm_no_more_"..math.random(1,10),"dialog_manager.precondition_"..str.."_dialogs_no_more")
			add_dialog(id,id2,"dm_do_not_know_"..math.random(1,10),"dialog_manager.precondition_"..str.."_dialogs_do_not_know")

		for k,v in pairs(phrase_table[str]) do
			ph = true
			add_dialog(id,v.id,v.name,"dialog_manager.precondition_"..str.."_dialogs","dialog_manager.action_"..str.."_dialogs")
		end

		if not (ph) then
			add_dialog(id,id2,"dm_"..str.."_do_not_know_"..math.random(1,3))
		end
	end
	add_dialog(1,get_id(),"dm_universal_actor_exit")
end

-- Fill selected priority table
function fill_priority_table(npc, PT_subtable, PRT_subtable)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]==nil) then
		PRT_subtable[npc_id] = {}
	end

	for num, phrase in pairs(PT_subtable) do
		if (phrase) then
			calculate_priority(PRT_subtable, phrase, npc, phrase.id)
		end
	end
end

function is_told(npc, str)
	local id = npc:id()
	if (priority_table[str] == nil or priority_table[str][id] == nil) then
		return true
	end
	if priority_table[str][id].told == true then
		return true
	end
	return false
end

-- Calculate precondition for default phrase in information dialog
function precondition_no_more(npc, str, phrase_id)
	local id = npc:id()
	if (priority_table[str] == nil or priority_table[str][id] == nil) then
		return true
	end

	local pr, id = get_highest_priority_phrase(phrase_table[str], priority_table[str], npc, phrase_id)
	if(pr<0) or (id==0) then
		printf("there is no avaliable "..str.." dialogs")
		return true
	end

	if (PRT_subtable[id][phrase_id] == nil or PRT_subtable[id][phrase_id] == -1) then
		return true
	end

	return false
end

-- Calculate phrase's preconditions
function precondition(npc, PT_subtable, PRT_subtable, phrase_id,dialog_name)
	if not (phrase_id) then
		printf("dialog_manager: no pharse_id for dialog %s",dialog_name)
	end

	if not (PRT_subtable[npc:id()]) then
		--printe("!ERROR dialog_manager |No PRT_subtable for %s with phrase_id=%s and dialog_name=%s",npc:name(),phrase_id,dialog_name)
		reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
		return false
	end

	if PRT_subtable[npc:id()] and PRT_subtable[npc:id()].told and PRT_subtable[npc:id()].told == true then
		return false
	end
-- recalculate current phrase priority
	local priority = calculate_priority(PRT_subtable, PT_subtable[phrase_id], npc, phrase_id)
-- if current phrase is with highest priority - show it
	return is_highest_priority_phrase(PT_subtable, PRT_subtable, npc, phrase_id)
end

-- Calculate phrase priority
function calculate_priority(PRT_subtable, PTID_subtable, npc, phrase_id)
	if not (PTID_subtable) then
		return
	end

	local f_level = false
	local f_comm = false
	local f_actor = false
	local priority = -1
	local npc_id = npc:id()
	
	-- Tronex
	if(PTID_subtable.important=="true") then
		priority = priority + 255
	end
	-- Tronex

	if(PTID_subtable.npc_community=="not_set") then
		f_comm = true
	elseif(PTID_subtable.npc_community[1]=="all") then
		priority = priority + 1
		f_comm = true
	else
		for i=1,#PTID_subtable.npc_community do
			if(PTID_subtable.npc_community[i]==character_community(npc)) then
				priority = priority + 2
				f_comm = true
				break
			end
		end
		priority = priority - 1
	end

	if(PTID_subtable.level=="not_set") then
		f_level = true
	elseif(PTID_subtable.level[1]=="all") then
		priority = priority + 1
		f_level = true
	else
		for i=1,#PTID_subtable.level do
			if(PTID_subtable.level[i]==level.name()) then
				priority = priority + 2
				f_level = true
				break
			end
		end
	end

	-- Tronex
	if(PTID_subtable.actor_community=="not_set") then
		f_actor = true
	elseif(PTID_subtable.actor_community[1]=="all") then
		f_actor = true
		priority = priority + 1
	else
		for i=1,#PTID_subtable.actor_community do
			if(PTID_subtable.actor_community[i] == get_actor_true_community()) then
				priority = priority + 1 --2
				f_actor = true
				break
			end
		end
	end
	-- Tronex

	if(PTID_subtable.wounded=="true") then
		if not(xr_wounded.is_wounded(npc)) then
			priority = -1
		else
			priority = priority + 1
		end
	else

	if(xr_wounded.is_wounded(npc)) then
		priority = -1
	else
		priority = priority + 1
		end
	end

	if f_comm == false or f_level == false or f_actor == false then
		priority = -1
	end

	if(PRT_subtable[npc_id].ignore_once) then
		if(PTID_subtable.once=="true") then
			priority = -1
		end
	end

	if(PRT_subtable[npc_id][phrase_id]~=nil) and (PRT_subtable[npc_id][phrase_id]==255) then
-- if there was set the highest priority for phrase
		priority = 255
	end

	for k,v in pairs(PTID_subtable.info) do
		if v.name then
			if v.required == true then
				if not has_alife_info(v.name) then
					priority = -1
					break
				end
			else
				if has_alife_info(v.name) then
					priority = -1
					break
				end
			end
		end
	end
	
	-- Tronex
	if PTID_subtable.condition and (PTID_subtable.condition ~= "") then
		local precond = xr_logic.parse_condlist(npc, "dialog_manager", "condition", PTID_subtable.condition)
		if (precond == "false") then
			priority = -1
		end
		if (db.actor and xr_logic.pick_section_from_condlist(db.actor, npc, precond) == "false") then
			--printf("-PTID_subtable.condition: %s",PTID_subtable.condition)
			priority = -1
		end
	end
	-- Tronex
	
	--printf("-PTID_subtable[%s] = %s", PTID_subtable.name, priority)


	PRT_subtable[npc_id][phrase_id] = priority
	return priority
end

-- Set phrase end action
function told(PRT_subtable, npc)
	PRT_subtable[npc:id()].told = true
end

function action(PT_subtable, PRT_subtable, cur_phrase_id, npc)
	if not(PRT_subtable[npc:id()].ignore_once) then
		if(PT_subtable[cur_phrase_id].once=="true") then
			set_phrase_highest_priority(PT_subtable,PRT_subtable, npc, cur_phrase_id)
		end
		
		-- Tronex
		local effect = PT_subtable[cur_phrase_id].effect
		if effect and (effect ~= "") then
			xr_logic.pick_section_from_condlist(db.actor, db.actor, effect)
			effect = ""
		end
		-- Tronex
		
		PRT_subtable[npc:id()].ignore_once = true
	end
end

-- Set the highest priority to selected phrase
function set_phrase_highest_priority(PT_subtable, PRT_subtable, npc, phrase_id)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]~=nil) then
		PRT_subtable[npc_id][phrase_id] = 255
	else
		PRT_subtable[npc_id] = {}
		PRT_subtable[npc_id][phrase_id] = 255
	end
end

-- Reset phrase priority
function reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
	if not (phrase_id) then
		return
	end

	local npc_id = npc:id()
	if(PRT_subtable[npc_id]) then
		PRT_subtable[npc_id][phrase_id] = -1
	else
		PRT_subtable[npc_id] = {}
		PRT_subtable[npc_id][phrase_id] = calculate_priority(PRT_subtable, PT_subtable[phrase_id], npc, phrase_id)
	end
end

-- Is the phrase priority the highest?
function is_highest_priority_phrase(PT_subtable, PRT_subtable, npc, phrase_id)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]~=nil) then
-- if there is a subtable for this npc
		local id = phrase_id
		local pr = PRT_subtable[npc_id][phrase_id]
		if pr == nil or pr < 0 then
			return false
		end
		for phr_id, priority in pairs(PRT_subtable[npc_id]) do
-- iterate through array to get if selected phrase is with the highest priority
			if(phr_id~="ignore_once" and phr_id~="told") then
				if(priority>pr) then
					return false
				end
			end
		end
		return true
	else
		-- if there is no subtable for this npc - create it
		reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
		return false
	end
end

-- Get the phrase with the highest priority
function get_highest_priority_phrase(PT_subtable, PRT_subtable, npc, phrase_id)
	local npc_id = npc:id()
	if(PRT_subtable[npc_id]) then
		-- if there is a subtable for this npc
		local id = 0
		local pr = -1
		for phr_id, priority in pairs(PRT_subtable[npc_id]) do
			-- iterate through array for the highest priority phrase
			if(phr_id~="ignore_once" and phr_id~="told") then
				if(priority>pr) then
					pr = priority
					id = phr_id
				end
			end
		end
		return pr, id
	else
		-- if there is no subtable for this npc - create it
		reset_phrase_priority(PT_subtable, PRT_subtable, npc, phrase_id)
		return -1, 0
	end
end

--------------------------------------------------------------------------------
-- Initializing, filling priority tables, setting preconditions and actions
--------------------------------------------------------------------------------
-- Initialize npc hello start dialog
function init_hello_dialogs(dialog)
	init_start_dialogs(dialog, "hello")
end

-- Fill phrase priority table for hello start dialog
function fill_priority_hello_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.hello, priority_table.hello)
end

-- Fill phrase priority table for new dialog
function fill_priority_job_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.job, priority_table.job)
end
function fill_priority_anomalies_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.anomalies, priority_table.anomalies)
end
--function fill_priority_place_table(actor, npc, dialog_name, phrase_id)
--	fill_priority_table(npc, phrase_table.place, priority_table.place)
--end
function fill_priority_information_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.information, priority_table.information)
end

function fill_priority_tips_table(actor, npc, dialog_name, phrase_id)
	fill_priority_table(npc, phrase_table.tips, priority_table.tips)
end

-- Calculate precondition for phrases in hello start dialog
function precondition_hello_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("hello")
	return precondition(npc, phrase_table.hello, priority_table.hello, id,dialog_name)
end

-- Set phrase end action for hello start dialog
function action_hello_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.hello, priority_table.hello, id, npc)
end

-- Calculate precondition for default phrase in occupation dialog
function precondition_job_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "job") == true then
		return true
	end
	return false
end

function precondition_job_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "job", id)
end

-- Calculate preconditions for phrases in occupation dialog
function precondition_job_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("job")
	return precondition(npc, phrase_table.job, priority_table.job, id,dialog_name)
end

-- Set phrase end action for occupation dialog
function action_job_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.job, priority_table.job, id, npc)
	told(priority_table.job, npc)
end

-- Calculate precondition for default phrase in anomalies dialog
function precondition_anomalies_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "anomalies") == true then
		return true
	end
	return false
end

function precondition_anomalies_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "anomalies", id)
end

-- Calculate preconditions for phrases in anomalies dialog
function precondition_anomalies_dialogs(npc, actor, dialog_name, parent_id, id)
	local smart = xr_gulag.get_npc_smart(npc)
	if priority_table.anomalies and priority_table.anomalies[npc:id()] and smart ~= nil and tostring(smart:name()) == phrase_table.anomalies[id].smart then
		priority_table.anomalies[npc:id()][id] = -1
		return false
	end
	--printf("anomalies")
	return precondition(npc, phrase_table.anomalies, priority_table.anomalies, id,dialog_name)
end

-- Set phrase end action for information dialog
function action_anomalies_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.anomalies, priority_table.anomalies, id, npc)
	told(priority_table.anomalies, npc)
end

-- Calculate precondition for default phrase in information dialog
function precondition_information_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "information") == true then
		return true
	end
	return false
end

function precondition_information_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "information", id)
end

-- Calculate preconditions for phrases in information dialog
function precondition_information_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("info")
	return precondition(npc, phrase_table.information, priority_table.information, id,dialog_name)
end

-- Set phrase end action for information dialog
function action_information_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.information, priority_table.information, id, npc)
	told(priority_table.information, npc)
end

-- Tips
-- Calculate precondition for default phrase in information dialog
function precondition_tips_dialogs_no_more(npc, actor, dialog_name, parent_id, id)
	if is_told(npc, "tips") == true then
		return true
	end
	return false
end

function precondition_tips_dialogs_do_not_know(npc, actor, dialog_name, parent_id, id)
	return precondition_no_more(npc, "tips", id)
end

-- Calculate preconditions for phrases in tips dialog
function precondition_tips_dialogs(npc, actor, dialog_name, parent_id, id)
	--printf("tips")
	return precondition(npc, phrase_table.tips, priority_table.tips, id,dialog_name)
end

-- Set phrase end action for tips dialog
function action_tips_dialogs(npc, actor, dialog_name, id)
	action(phrase_table.tips, priority_table.tips, id, npc)
	told(priority_table.tips, npc)
end

local rnd = 0

function precondition_is_phrase_disabled(fs,ss,dn,ppi,pi)
	local npc = dialogs.who_is_npc(fs, ss)
	if(pi=="") then
		pi = dn
	end
	if (disabled_phrases[npc:id()] and disabled_phrases[npc:id()][pi]) or
		 (quest_disabled_phrases[npc:id()] and quest_disabled_phrases[npc:id()][pi]) then
		return false
	else
		return true
	end
end

function action_disable_phrase(fs,ss,dn,pi)
	local npc = dialogs.who_is_npc(fs, ss)
	if(pi=="0") then
		pi = dn
	end
	if(disabled_phrases[npc:id()]==nil) then
		disabled_phrases[npc:id()] = {}
	end
	disabled_phrases[npc:id()][pi] = true
end

function action_disable_quest_phrase(fs,ss,dn,pi)
	local npc = dialogs.who_is_npc(fs, ss)
	if(pi=="0") then
		pi = dn
	end
	if(quest_disabled_phrases[npc:id()]==nil) then
		quest_disabled_phrases[npc:id()] = {}
	end
	quest_disabled_phrases[npc:id()][pi] = true
end

function create_bye_phrase()
	return game.translate_string("actor_break_dialog_"..RandomVal)
end

function uni_dialog_precond(first_speaker, second_speaker)
	local npc = dialogs.who_is_npc(first_speaker, second_speaker)
	return character_community(npc) ~= "zombied" and character_community(npc) ~= "monolith"
end
