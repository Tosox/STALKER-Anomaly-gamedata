local cam_effector_sets = {
mar_intro_effector = {
					start = 	{
									{anm = "scenario_cam\\marsh\\camera_mar_02_up", looped = false, global_cameffect = true},
								},
					idle =  	{
								    {anm = "scenario_cam\\marsh\\camera_mar_04_on_foot", looped = false, global_cameffect = true},
								},
					finish =	{
								}
				},

pri_a15_cameffector = {
					start = {
							},
					idle = {
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_01", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_02", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_03", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_04", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_05", looped = "false", global_cameffect = true, enabled = "{+pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_06", looped = "false", global_cameffect = true, enabled = "{+pri_a15_vano_out +pri_a15_wanderer_out +pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_07", looped = "false", global_cameffect = true, enabled = "{+pri_a15_vano_out +pri_a15_wanderer_out +pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_08", looped = "false", global_cameffect = true, enabled = "{+pri_a15_vano_out +pri_a15_sokolov_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_09", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_10", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_11", looped = "false", global_cameffect = true, enabled = "{+pri_a15_sokolov_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_12", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_13", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_14", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_15", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_16", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_17", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_17_1", looped = "false", global_cameffect = true, enabled = "{+pri_a15_all_dead} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_18", looped = "false", global_cameffect = true, enabled = "{+pri_a15_all_dead} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_19", looped = "false", global_cameffect = true, enabled = "{+pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_20", looped = "false", global_cameffect = true, enabled = "{+pri_a15_sokolov_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_21", looped = "false", global_cameffect = true, enabled = "{+pri_a15_sokolov_out +pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_22", looped = "false", global_cameffect = true, enabled = "{+pri_a15_vano_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_23", looped = "false", global_cameffect = true, enabled = "{+pri_a15_vano_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_24", looped = "false", global_cameffect = true, enabled = "{+pri_a15_vano_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_25", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_25_1", looped = "false", global_cameffect = true, enabled = "{+pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_26", looped = "false", global_cameffect = true, enabled = "{+pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_27", looped = "false", global_cameffect = true, enabled = "{+pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_28", looped = "false", global_cameffect = true, enabled = "{+pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_29", looped = "false", global_cameffect = true, enabled = "{+pri_a15_zulus_out} false, true"},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_30", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_31", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_a15_cam_32", looped = "false", global_cameffect = true}
							},
					finish = {
							}
				},

jup_b219_descent_camera = {
					start = {
							},
					idle = {
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_1", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_2", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_3", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_4", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_5", looped = "false", global_cameffect = true, enabled = "{+jup_a10_vano_agree_go_und} true, false"},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_6", looped = "false", global_cameffect = true, enabled = "{+jup_b218_monolith_hired} true, false"},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_7", looped = "false", global_cameffect = true, enabled = "{+jup_b218_soldier_hired} true, false"},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_8", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_9", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\Jupiter\\jup_b219_cam_10", looped = "false", global_cameffect = true, enabled = "true %+jup_b219_entering_underpass%"},

							},
					finish = {
							}
					},
pri_b305_camera_2 = {
						start = {
								},
						idle = {
									{anm = "scenario_cam\\pripyat\\pri_b305_catscene_2_dialog_with_kovalsky_01", looped = "false", global_cameffect = true},
									{anm = "scenario_cam\\pripyat\\pri_b305_catscene_2_dialog_with_kovalsky_02", looped = "false", global_cameffect = true},
								},
						finish = {
								}
					},

pri_b305_camera_5 = {
					start = {
							},
					idle = {
								{anm = "scenario_cam\\pripyat\\pri_b305_catscene_5_dialog_with_strelok_1", looped = "false", global_cameffect = true},
								{anm = "scenario_cam\\pripyat\\pri_b305_catscene_5_dialog_with_strelok_2", looped = "false", global_cameffect = true},
							},
					finish = {
							}
					}
}

----------------------------------------------------------------------------------------------------
--' Cutscene trigger
----------------------------------------------------------------------------------------------------
--' Временные переменные
local object_cutscene = nil
local storage_scene = nil

class "cam_effector_set"
function cam_effector_set:__init(set,storage)
	self.set = set
	self.state = "start"
	self.cur_effect = 0
	self.playing = false
	self.looped = false
	self.enabled = true
	self.st = storage
end

function cam_effector_set:start_effect(eff)
	--printf("playing effect [camera_effects\\"..eff.anm..".anm], time [%s]", device():time_global())
	--callstack()

	if not (eff.global_cameffect) then
		level.add_cam_effector("camera_effects\\"..eff.anm..".anm", 210408, false, "sr_cutscene.effector_callback")
	else
		level.add_cam_effector("camera_effects\\"..eff.anm..".anm", 210408, false, "sr_cutscene.effector_callback", self.st.fov or db.actor:fov()*0.75)
	end
	self.playing = true
end

function cam_effector_set:stop_effect()
	level.remove_cam_effector(210408)
	self.playing = false
	self.state = "release"
	self.cur_effect = 0
end

function cam_effector_set:update()
	if(device().precache_frame > 0) then
		return
	end
	if(self.playing) then
		local eff = self.set[self.state][self.cur_effect]
		if(eff) and (eff.looped~=false) then
			local cond = xr_logic.pick_section_from_condlist(db.actor, nil, self.condlist)
			if(cond=="false") then
				self.looped = false
				--self:stop_effect()
			end
		end
	else
		local eff = self:select_effect()
		if(eff) then
			self:start_effect(eff)
		end
	end
end

function cam_effector_set:select_effect()
	local state = self.state
	local cur_effect = self.cur_effect
	if(self.looped) then
		return self.set[state][cur_effect]
	end
	if(state=="start") then
		cur_effect = cur_effect + 1
		if(self.set.start[cur_effect]) then
			self.cur_effect = cur_effect
			if type(self.set.start[cur_effect].enabled)=="string" then
				local condlist = xr_logic.parse_condlist(db.actor, "sr_cutscene", "enabled_condlist", self.set.start[cur_effect].enabled)
				if xr_logic.pick_section_from_condlist(db.actor, nil, condlist) == "false" then
					return self:select_effect()
				end
			end
			if(type(self.set.start[cur_effect].looped)=="string") then
				self.looped = true
				self.condlist = xr_logic.parse_condlist(db.actor, "sr_cutscene", "effect_condlist", self.set.start[cur_effect].looped)
			end
			return self.set.start[cur_effect]
		else
			self.state = "idle"
			self.cur_effect = 0
			return self:select_effect()
		end
	elseif(state=="idle") then
		cur_effect = cur_effect + 1
		if(self.set.idle[cur_effect]) then
			self.cur_effect = cur_effect
			if type(self.set.idle[cur_effect].enabled)=="string" then
				local condlist = xr_logic.parse_condlist(db.actor, "sr_cutscene", "enabled_condlist", self.set.idle[cur_effect].enabled)
				if xr_logic.pick_section_from_condlist(db.actor, nil, condlist) == "false" then
					return self:select_effect()
				end
			end
			if(type(self.set.idle[cur_effect].looped)=="string") then
				self.looped = true
				self.condlist = xr_logic.parse_condlist(db.actor, "sr_cutscene", "effect_condlist", self.set.idle[cur_effect].looped)
			end
			return self.set.idle[cur_effect]
		else
			self.state = "finish"
			self.cur_effect = 0
			return self:select_effect()
		end
	elseif(state=="finish") then
		cur_effect = cur_effect + 1
		if(self.set.finish[cur_effect]) then
			self.cur_effect = cur_effect
			if type(self.set.finish[cur_effect].enabled)=="string" then
				local condlist = xr_logic.parse_condlist(db.actor, "sr_cutscene", "enabled_condlist", self.set.finish[cur_effect].enabled)
				if xr_logic.pick_section_from_condlist(db.actor, nil, condlist) == "false" then
					return self:select_effect()
				end
			end
			if(type(self.set.finish[cur_effect].looped)=="string") then
				self.looped = true
				self.condlist = xr_logic.parse_condlist(db.actor, "sr_cutscene", "effect_condlist", self.set.finish[cur_effect].looped)
			end
			return self.set.finish[cur_effect]
		else
			self.state = "release"
			self.cur_effect = 0
			sr_cutscene.effector_callback()
			return nil
		end
	end
end
--------------------------------------------------------------------------------
class "action_cutscene"
--' инициализация объекта класса
function action_cutscene:__init(obj, storage)
	self.object = obj
	self.st = storage
	self.ui_disabled = false
	self.motion_id = 1
	self.postprocess = false
end
--' инициализация схемы поведения
function action_cutscene:reset_scheme()
	self.state = ""
	self.st.signals = {} --' обнуляем сигналы
	self.motion = nil

	self:zone_enter()
end
--' функция обновления, вызываемая конвеером
function action_cutscene:update(delta)
	local state = self.state
--	if(state~="run") then
--		self:zone_enter()
--	end

	if(self.motion) then
		self.motion:update()
	    if(self.st.signals["cam_effector_stop"]~=nil) then
	        self.motion:stop_effect()
			self:cutscene_callback()
			self.st.signals["cam_effector_stop"] = nil
	    end
	end
		--' выполняем архитектурное требование
	if(xr_logic.try_switch_to_another_section(self.object, self.st, db.actor)) then
		return
	end
end
--' тут нужно запустить сцену
function action_cutscene:zone_enter()
	self.state = "run"
	--' телепорт в выбранную точку
	--printf("%s ZONE ENTER %s", self.object:name(), device():time_global())

	xr_effects.teleport_actor(db.actor, self.object, {self.st.point, self.st.look})

	if self.st.pp_effector ~= "nil.ppe" then
		level.add_pp_effector(self.st.pp_effector, 234, false)
	end

 	xr_effects.disable_ui(db.actor, nil)
	self.ui_disabled = true

	if self.st.outdoor and db.actor ~= nil and (level.get_time_hours() < 6 or level.get_time_hours() > 21) then
		self.postprocess = true
		level.add_complex_effector("brighten", 1999)
		--level.add_pp_effector("brighten.ppe", 1999, true)
	end

	self.motion_id = 1
	self:select_next_motion()

	object_cutscene = self.object
	storage_scene = self.st
end
--' Выбор и начало отыгрыша следующего пролета
function action_cutscene:select_next_motion()
	local motion = self.st.cam_effector[self.motion_id]

	if (cam_effector_sets == nil or cam_effector_sets[motion] == nil) then --Это имя файла, а не имя таблицы.
		self.motion = cam_effector_set({start={},idle={{anm=motion, looped=false, global_cameffect = self.st.global_cameffect}},finish={}}, self.st)
	else
		self.motion = cam_effector_set(cam_effector_sets[motion], self.st)
	end

	local effect = self.motion:select_effect()
	self.motion:start_effect(effect)

	self.motion_id = self.motion_id + 1
end
--' Ивент об окончании пролета
function action_cutscene:cutscene_callback()
	if(self.motion.state=="release") then
		self.motion = nil
		if(self.motion_id<=#self.st.cam_effector) then
			self:select_next_motion()
			--printf("SELECTING MOTION %s from %s", tostring(self.motion_id), tostring(#self.st.cam_effector))
		else
			if self.postprocess then
				self.postprocess = false
				level.remove_complex_effector(1999)
				--level.remove_pp_effector(1999)
			end
			if(self.ui_disabled) then
				if not db.actor:is_talking() and self.st.enable_ui_on_end then
					xr_effects.enable_ui(db.actor, nil)
				elseif self.st.enable_ui_on_end then
					level.enable_input()
				end
				db.actor:set_actor_direction(-patrol(self.st.look):point(0):sub(patrol(self.st.point):point(0)):getH())
				self.ui_disabled = false
				self.st.signals["cameff_end"] = true
			end
		end
	else
		self.motion.playing = false
		local eff = self.motion:select_effect()
		if(eff) then
			self.motion:start_effect(eff)
		end
	end
end
--------------------------------------------------------------------------------
function add_to_binder(npc, ini, scheme, section, storage)
	local new_action = action_cutscene(npc, storage)

	storage.cutscene_action = new_action
	--' Зарегистрировать все actions, в которых должен быть вызван метод reset_scheme при изменении настроек схемы:
	xr_logic.subscribe_action_for_events(npc, storage, new_action)
end
function set_scheme(obj, ini, scheme, section, gulag_name)
	local st = xr_logic.assign_storage_and_bind(obj, ini, scheme, section)
	st.logic = xr_logic.cfg_get_switch_conditions(ini, section, obj)

	st.point = ini:r_string_ex(section,"point") or "none"
	st.look = ini:r_string_ex(section,"look") or "none"
	st.global_cameffect = ini:r_bool_ex(section,"global_cameffect",false)
	st.pp_effector = tostring(ini:r_string_ex(section,"pp_effector"))..".ppe"
	st.cam_effector = parse_names(ini:r_string_ex(section,"cam_effector") or "")
	st.fov = ini:r_float_ex(section,"fov")

	st.enable_ui_on_end = ini:r_bool_ex(section,"enable_ui_on_end",true)
	st.outdoor = ini:r_bool_ex(section,"outdoor",false)
end
function effector_callback(obj)
	xr_logic.issue_event(object_scene, storage_scene, "cutscene_callback")
end
